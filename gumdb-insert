#!/usr/bin/env python3
import argparse
import sys
import sqlite3
import pathlib
import email
import email.utils
import email.parser
import email.policy
import uuid
import mailbox
import os.path
import time

def insert(conn, message_bytes, source = None):
    # We'd like to use the "default" policy (which isn't the default)
    # and take advantage of its structured header classes, but
    # <https://bugs.python.org/issue35342> makes it unusable.
    parser = email.parser.BytesParser(policy = email.policy.compat32)
    message = parser.parsebytes(message_bytes, headersonly = True)

    id = uuid.uuid4().hex
    conn.execute('INSERT INTO messages (id, message) VALUES (?, ?)', (id, message_bytes))

    if source:
        source['id'] = id
        fields = ['id', 'type', 'file', 'key', 'mtime']
        conn.execute(
            f'''
               INSERT INTO sources ({','.join(fields)})
               VALUES ({','.join(':'+f for f in fields)})
            ''',
            {f:source.get(f) for f in fields}
        )

    conn.executemany('INSERT INTO headers (id, name, value) VALUES (?, ?, ?)',
                     [(id, name.lower(), str(value)) for name, value in message.items()])

    # See
    # <https://docs.python.org/3.7/library/email.headerregistry.html#email.headerregistry.HeaderRegistry>
    # for the origin of this list of headers.
    values = []
    for header in ['to', 'from', 'cc', 'bcc', 'resent-to', 'resent-from',
                   'sender', 'resent-sender', 'reply-to']:
        addresses = email.utils.getaddresses([str(h) for h in (message.get_all(header) or ())])
        for name, address in addresses:
            if address != '':
                values.append((id, header, name, address))
    conn.executemany('INSERT INTO addresses (id, header, name, address) VALUES (?, ?, ?, ?)', values)

    # See
    # <https://docs.python.org/3.7/library/email.headerregistry.html#email.headerregistry.HeaderRegistry>
    # for the origin of this list of headers.
    values = []
    for header in ['date', 'resent-date', 'orig-date']:
        for value in (message.get_all(header) or ()):
            try:
                # TODO: Docs don't say what date.datetime is if the
                # header isn't parseable.  It seems to just break in
                # undocumented ways.  See
                # <https://bugs.python.org/issue30681>.
                values.append((id, header, email.utils.parsedate_to_datetime(value)))
            except:
                pass
    conn.executemany('INSERT INTO dates (id, header, date) VALUES (?, ?, ?)', values)

    unixfrom = message.get_unixfrom()
    if unixfrom:
        conn.execute('INSERT INTO envelopes (id, unixfrom) VALUES (?, ?)', (id, unixfrom))

    conn.commit()

def schema(conn):
    # WITHOUT ROWID is possible for the messages table, but not
    # recommended because it has large rows.  See
    # <https://sqlite.org/withoutrowid.html>.
    conn.execute('''
        CREATE TABLE IF NOT EXISTS messages (
            id TEXT PRIMARY KEY NOT NULL,
            message BLOB NOT NULL
        )
    ''')

    conn.execute('''
        CREATE TABLE IF NOT EXISTS sources (
            id TEXT
                PRIMARY KEY
                NOT NULL
                REFERENCES messages(id)
                ON DELETE CASCADE,
            type TEXT NOT NULL,
            file TEXT,
            key TEXT,
            mtime FLOAT
        )
    ''')

    # headers.id can't be a primary key because messages have more
    # than one header.  (headers.id, headers.name) can't be a primary
    # key because messages can have more than one header with the same
    # name (and possibly even the same value).  So the headers table
    # is a real bag, not a set.
    conn.execute('''
        CREATE TABLE IF NOT EXISTS headers (
            id TEXT
              NOT NULL
              REFERENCES messages(id)
              ON DELETE CASCADE,
            name TEXT NOT NULL,
            value TEXT NOT NULL
        )
    ''')
    conn.execute('CREATE INDEX IF NOT EXISTS headers_id ON headers (id)')

    # (addresses.id, addresses.header) can't be a primary key because
    # messages may have more than one address header with the same
    # name (and value), e.g. Two "To" headers.
    conn.execute('''
        CREATE TABLE IF NOT EXISTS addresses (
            id TEXT
              NOT NULL
              REFERENCES messages(id)
              ON DELETE CASCADE,
            header TEXT NOT NULL,
            name TEXT,
            address TEXT NOT NULL
        )
    ''')
    conn.execute('CREATE INDEX IF NOT EXISTS addresses_id on addresses (id)')

    conn.execute('''
        CREATE TABLE IF NOT EXISTS dates (
            id TEXT
              NOT NULL
              REFERENCES messages(id)
              ON DELETE CASCADE,
            header TEXT NOT NULL,
            date TEXT NOT NULL
        )
    ''')
    conn.execute('CREATE INDEX IF NOT EXISTS dates_id on dates (id)')

    conn.execute('''
        CREATE TABLE IF NOT EXISTS envelopes (
            id TEXT
              NOT NULL
              PRIMARY KEY
              REFERENCES messages(id)
              ON DELETE CASCADE,
            unixfrom TEXT NOT NULL
        ) WITHOUT ROWID
    ''')
    
def main():
    parser = argparse.ArgumentParser(description = 'Insert a new email message into the GUMDB.')
    parser.add_argument('--database',
                        nargs = 1,
                        default = [pathlib.Path.home() / 'var/gumdb.sqlite3'],
                        help = 'path to database file')
    parser.add_argument('--mbox',
                        action = 'store_const',
                        const = True,
                        default = False,
                        help = 'accept a mailbox of messages in mbox format')
    parser.add_argument('--dots',
                        action = 'store_const',
                        const = True,
                        default = False,
                        help = 'print one dot per message to standard output to show progress')
    parser.add_argument('file',
                        nargs = '+',
                        help = 'one or more files from which to read messages')
    args = parser.parse_args()

    # TODO: Make sure it's not autocommit
    conn = sqlite3.connect(str(args.database[0]), timeout=60)
    # See <https://sqlite.org/foreignkeys.html>.
    if conn.execute('PRAGMA foreign_keys'):
        conn.execute('PRAGMA foreign_keys = ON')
    else:
        # TODO: Proper warning output
        print('WARNING: foreign keys not supported in sqlite3. Database may accumulate cruft.')
    schema(conn)

    for file in args.file:
        if args.mbox:
            box = mailbox.mbox(file, create = False)
            # TODO: locking?
            mtime = os.path.getmtime(file)
            for key in box.iterkeys():
                insert(conn,
                       box.get_bytes(key, from_ = True),
                       source = dict(type = 'mbox',
                                     file = file,
                                     key = key,
                                     mtime = mtime))
                if args.dots: print('.', end = '', flush = True)
            if args.dots: print(flush = True)
        else:
            if file == '-':
                insert(conn,
                       sys.stdin.buffer.read(),
                       source = dict(type = 'file',
                                     mtime = time.time()))
            else:
                insert(conn,
                       open(file, 'rb').read(),
                       source = dict(type = 'file',
                                     file = file,
                                     mtime = os.path.getmtime(file)))

if __name__ == '__main__':
    main()
