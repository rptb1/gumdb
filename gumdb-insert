#!/usr/bin/env python3
import argparse
import sys
import sqlite3
import pathlib
import email
import email.utils
import email.parser
import email.policy
import uuid
import mailbox

def insert(conn, message_bytes, source=None):
    # We'd like to use the "default" policy (which isn't the default)
    # and take advantage of its structured header classes, but
    # <https://bugs.python.org/issue35342> makes it unusable.
    parser = email.parser.BytesParser(policy = email.policy.compat32)
    message = parser.parsebytes(message_bytes, headersonly = True)

    id = uuid.uuid4().hex
    conn.execute('INSERT INTO messages (id, message, source) VALUES (?, ?, ?)', (id, message_bytes, source))

    conn.executemany('INSERT INTO headers (id, name, value) VALUES (?, ?, ?)',
                     [(id, name.lower(), str(value)) for name, value in message.items()])

    # See
    # <https://docs.python.org/3.7/library/email.headerregistry.html#email.headerregistry.HeaderRegistry>
    # for the origin of this list of headers.
    values = []
    for header in ['to', 'from', 'cc', 'bcc', 'resent-to', 'resent-from',
                   'sender', 'resent-sender', 'reply-to']:
        addresses = email.utils.getaddresses([str(h) for h in (message.get_all(header) or ())])
        for name, address in addresses:
            if address != '':
                values.append((id, header, name, address))
    conn.executemany('INSERT INTO addresses (id, header, name, address) VALUES (?, ?, ?, ?)', values)

    # See
    # <https://docs.python.org/3.7/library/email.headerregistry.html#email.headerregistry.HeaderRegistry>
    # for the origin of this list of headers.
    values = []
    for header in ['date', 'resent-date', 'orig-date']:
        for value in (message.get_all(header) or ()):
            try:
                # TODO: Docs don't say what date.datetime is if the
                # header isn't parseable.  It seems to just break in
                # undocumented ways.  See
                # <https://bugs.python.org/issue30681>.
                values.append((id, header, email.utils.parsedate_to_datetime(value)))
            except:
                pass
    conn.executemany('INSERT INTO dates (id, header, date) VALUES (?, ?, ?)', values)

    unixfrom = message.get_unixfrom()
    if unixfrom:
        conn.execute('INSERT INTO envelopes (id, unixfrom) VALUES (?, ?)', (id, unixfrom))

    conn.commit()

def schema(conn):
    # WITHOUT ROWID is possible for the messages table, but not
    # recommended because it has large rows.  See
    # <https://sqlite.org/withoutrowid.html>.
    conn.execute('''
        CREATE TABLE IF NOT EXISTS messages (
            id TEXT PRIMARY KEY NOT NULL,
            message BLOB NOT NULL,
            source TEXT
        )
    ''')
    conn.execute('''
        CREATE TABLE IF NOT EXISTS headers (
            id TEXT NOT NULL,
            name TEXT NOT NULL,
            value TEXT NOT NULL
        )
    ''')
    conn.execute('CREATE INDEX IF NOT EXISTS headers_id ON headers (id)')
    conn.execute('''
        CREATE TABLE IF NOT EXISTS addresses (
            id TEXT NOT NULL,
            header TEXT NOT NULL,
            name TEXT,
            address TEXT NOT NULL
        )
    ''')
    conn.execute('CREATE INDEX IF NOT EXISTS addresses_id on addresses (id)')
    conn.execute('''
        CREATE TABLE IF NOT EXISTS dates (
            id TEXT NOT NULL,
            header TEXT NOT NULL,
            date TEXT NOT NULL
        )
    ''')
    conn.execute('CREATE INDEX IF NOT EXISTS dates_id on dates (id)')
    conn.execute('''
        CREATE TABLE IF NOT EXISTS envelopes (
            id TEXT PRIMARY KEY NOT NULL,
            unixfrom TEXT NOT NULL
        ) WITHOUT ROWID
    ''')
    
def main():
    parser = argparse.ArgumentParser(description = 'Insert a new email message into the GUMDB.')
    parser.add_argument('--database',
                        nargs = 1,
                        default = pathlib.Path.home() / 'var/gumdb.sqlite3',
                        help = 'path to database file')
    parser.add_argument('--mbox',
                        action = 'store_const',
                        const = True,
                        default = False,
                        help = 'accept a mailbox of messages in mbox format')
    parser.add_argument('--dots',
                        action = 'store_const',
                        const = True,
                        default = False,
                        help = 'print one dot per message to standard output to show progress')
    parser.add_argument('file',
                        nargs = '+',
                        help = 'one or more files from which to read messages')
    args = parser.parse_args()

    # TODO: Make sure it's not autocommit
    conn = sqlite3.connect(str(args.database[0]), timeout=60)
    schema(conn)

    for file in args.file:
        if args.mbox:
            box = mailbox.mbox(file, create = False)
            for key in box.iterkeys():
                # TODO: Store the modification time of the source
                # file, so that we have a permanent unique idea of
                # where the message came from, even if the mailbox
                # changes. TODO: Remember the this is an mbox file, so
                # that we can have others.
                insert(conn, box.get_bytes(key, from_ = True), source = repr((file, key)))
                if args.dots: print('.', end = '', flush = True)
            if args.dots: print(flush = True)
        else:
            if file == '-':
                insert(conn, sys.stdin.buffer.read(), source = 'stdin')
            else:
                insert(conn, open(file, 'rb').read(), source = file)

if __name__ == '__main__':
    main()
